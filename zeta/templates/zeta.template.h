/* ***************************************************************** */
/*                      FILE GENERATED BY ZetaCLI                    */
/*                         DON'T EDIT THIS FILE                      */
/* ***************************************************************** */

/**
 * @file   zeta.template.h
 * @author Rodrigo Peixoto
 * @author Lucas Peixoto <lucaspeixotoac@gmail.com>
 *
 * @brief Zeta header file
 *
 *
 */


#ifndef ZETA_H_
#define ZETA_H_


#include <stddef.h>
#include <zephyr.h>
#include <zephyr/types.h>

/**
 * @brief Stack size that is used in Zeta thread that manages the
 * persistent data.
 *
 */
#define ZT_THREAD_NVS_STACK_SIZE 512

/**
 * @brief Stack size that is used in Zeta thread that manages
 * callback calls.
 *
 */
#define ZT_THREAD_STACK_SIZE 512

/**
 * @brief Priority that is used for all Zeta threads.
 *
 */
#define ZT_THREAD_PRIORITY 0

/**
 * @brief Get variable reference and size easily to use in
 * Zeta API.
 *
 * @param x variable name
 *
 */
#define ZT_VARIABLE_REF_SIZE(x) (u8_t *) (&x), sizeof(x)

/**
 * @brief Check if _v value is equal to _c, otherwise _err will be
 * returned and a message will be sent to LOG.
 *
 * @param _v Value
 * @param _c Condition
 * @param _err Error code
 *
 */
#define ZT_CHECK_VAL(_p, _e, _err, ...) \
    if (_p == _e) {                     \
        LOG_INF(__VA_ARGS__);           \
        return _err;                    \
    }

/**
 * @brief Check if _v is true, otherwise _err will be returned and a
 * message will be sent to LOG.
 *
 * @param _v Value
 * @param _err Error code
 *
 * @return
 */
#define ZT_CHECK(_p, _err, ...) \
    if (_p) {                   \
        LOG_INF(__VA_ARGS__);   \
        return _err;            \
    }


#define ZT_DATA_S8(data)               \
    (zt_data_t *) (zt_data_s8_t[])     \
    {                                  \
        {                              \
            sizeof(s8_t), (s8_t)(data) \
        }                              \
    }

#define ZT_DATA_U8(data)               \
    (zt_data_t *) (zt_data_u8_t[])     \
    {                                  \
        {                              \
            sizeof(u8_t), (u8_t)(data) \
        }                              \
    }

#define ZT_DATA_S16(data)                \
    (zt_data_t *) (zt_data_s16_t[])      \
    {                                    \
        {                                \
            sizeof(s16_t), (s16_t)(data) \
        }                                \
    }

#define ZT_DATA_U16(data)                \
    (zt_data_t *) (zt_data_u16_t[])      \
    {                                    \
        {                                \
            sizeof(u16_t), (u16_t)(data) \
        }                                \
    }

#define ZT_DATA_S32(data)                \
    (zt_data_t *) (zt_data_s32_t[])      \
    {                                    \
        {                                \
            sizeof(s32_t), (s32_t)(data) \
        }                                \
    }

#define ZT_DATA_U32(data)                \
    (zt_data_t *) (zt_data_u32_t[])      \
    {                                    \
        {                                \
            sizeof(u32_t), (u32_t)(data) \
        }                                \
    }

#define ZT_DATA_S64(data)                \
    (zt_data_t *) (zt_data_s64_t[])      \
    {                                    \
        {                                \
            sizeof(s64_t), (s64_t)(data) \
        }                                \
    }

#define ZT_DATA_U64(data)                \
    (zt_data_t *) (zt_data_u64_t[])      \
    {                                    \
        {                                \
            sizeof(u64_t), (u64_t)(data) \
        }                                \
    }

#define ZT_DATA_BYTES(_size, data, ...) \
    (zt_data_t *) (struct {             \
        size_t size;                    \
        u8_t value[_size];              \
    }[])                                \
    {                                   \
        {                               \
            _size,                      \
            {                           \
                data, ##__VA_ARGS__     \
            }                           \
        }                               \
    }

typedef struct {
    size_t size;
    s8_t value;
} zt_data_s8_t;

typedef struct {
    size_t size;
    u8_t value;
} zt_data_u8_t;

typedef struct {
    size_t size;
    s16_t value;
} zt_data_s16_t;

typedef struct {
    size_t size;
    u16_t value;
} zt_data_u16_t;

typedef struct {
    size_t size;
    s32_t value;
} zt_data_s32_t;

typedef struct {
    size_t size;
    u32_t value;
} zt_data_u32_t;

typedef struct {
    size_t size;
    s64_t value;
} zt_data_s64_t;

typedef struct {
    size_t size;
    u64_t value;
} zt_data_u64_t;

typedef struct {
    size_t size;
    u8_t value[];
} zt_data_bytes_t;

union data {
    zt_data_s8_t s8;
    zt_data_u8_t u8;
    zt_data_s16_t s16;
    zt_data_u16_t u16;
    zt_data_s32_t s32;
    zt_data_u32_t u32;
    zt_data_s64_t s64;
    zt_data_u64_t u64;
    zt_data_bytes_t bytes;
};

typedef union data zt_data_t;

//$channels_enum

/**
 * @brief zeta_callback_f define the callback function type of Zeta.
 *
 * @param id Channel Id.
 *
 */
typedef void (*zt_callback_f)(zt_channel_e id);

/**
 * @brief Define pendent options that a channel can have.
 */
union opt_data {
    struct {
        u8_t pend_persistent : 1; /**< Active represent that channel must be saved in
                                     flash by zeta_thread_nvs */
        u8_t pend_callback : 1;   /**< Active represent that services callbacks from
                                     subscribers must be called by zeta_thread */
    } field;
    u8_t data; /**< Raw data */
};

/**
 * @brief Define Zeta channel type
 */
struct zt_channel {
    const char *name;                         /**< Channel name */
    u8_t *data;                               /**< Channel raw data */
    int (*validate)(u8_t *data, size_t size); /**< Valid data sent to be set to channel */
    int (*pre_get)(zt_channel_e id, u8_t *channel_value,
                   size_t size); /**< Called before some get call */
    int (*get)(zt_channel_e id, u8_t *channel_value, size_t size); /**< Get call */
    int (*pos_get)(zt_channel_e id, u8_t *channel_value,
                   size_t size); /**< Called after some get call */
    int (*pre_set)(zt_channel_e id, u8_t *channel_value,
                   size_t size); /**< Called before some set call */
    int (*set)(zt_channel_e id, u8_t *channel_value, size_t size); /**< Set call */
    int (*pos_set)(zt_channel_e id, u8_t *channel_value,
                   size_t size);    /**< Called after some set call */
    u8_t size;                      /**< Channel size */
    u8_t persistent;                /**< Persistent type */
    union opt_data opt;             /**< Pendent options */
    struct k_sem *sem;              /**< Preserve shared-memory */
    const k_tid_t *publishers_id;   /**< Publishers Ids */
    zt_callback_f *subscribers_cbs; /**< Subscribers callbacks */
    zt_channel_e id;                /**< Channel Id */
};
typedef struct zt_channel zt_channel_t;

/**
 * @brief Return the channel size.
 *
 * @param id Channel Id
 * @param error Handle possible errors
 *
 * @return Channel size
 */
size_t zt_channel_size(zt_channel_e id, int *error);

/**
 * @brief Return the channel name.
 *
 * @param id Channel Id
 * @param error Handle possible errors
 *
 * @return Channel name
 */
const char *zt_channel_name(zt_channel_e id, int *error);

/**
 * @brief Get channel value.
 *
 * @param id Channel Id
 * @param channel_data pointer to a zt_data_t where the data will be retrieved.
 *
 * @return Error code
 * @retval -ENODATA The channel was not found
 * @retval -EFAULT Channel value is NULL
 * @retval -EPERM  Channel hasn't get function implemented
 * @retval -EINVAL Size passed is different to channel size
 */
int zt_channel_data_get(zt_channel_e id, zt_data_t *channel_data);

/**
 * @brief Get channel value.
 *
 * @param id Channel Id
 * @param channel_value Handle channel value
 * @param size Channel size
 *
 * @return Error code
 * @retval -ENODATA The channel was not found
 * @retval -EFAULT Channel value is NULL
 * @retval -EPERM  Channel hasn't get function implemented
 * @retval -EINVAL Size passed is different to channel size
 */
int zt_channel_get(zt_channel_e id, u8_t *channel_value, size_t size);

/**
 * @brief Set channel value.
 *
 * @param id Channel Id
 * @param channel_data pointer to a zt_data_t where the data is.
 *
 * @return Error code
 * @retval -ENODATA The channel was not found
 * @retval -EACCESS Current thread hasn't permission to set this channel
 * @retval -EFAULT Channel value is NULL
 * @retval -EPERM Channel is read only
 * @retval -EINVAL Size passed is different to channel size
 * @retval -EAGAIN Valid function returns false
 */
int zt_channel_data_set(zt_channel_e id, zt_data_t *channel_data);

/**
 * @brief Set channel value.
 *
 * @param id Channel Id
 * @param channel_value New channel value
 * @param size Channel size
 *
 * @return Error code
 * @retval -ENODATA The channel was not found
 * @retval -EACCESS Current thread hasn't permission to set this channel
 * @retval -EFAULT Channel value is NULL
 * @retval -EPERM Channel is read only
 * @retval -EINVAL Size passed is different to channel size
 * @retval -EAGAIN Valid function returns false
 */
int zt_channel_set(zt_channel_e id, u8_t *channel_value, size_t size);

#endif
