/* ***************************************************************** */
/*                      FILE GENERATED BY ZetaCLI                    */
/*                         DON'T EDIT THIS FILE                      */
/* ***************************************************************** */

#ifndef ZETA_H_
#define ZETA_H_


#include <stddef.h>
#include <zephyr.h>
#include <zephyr/types.h>

/**
 * @brief Stack size that is used in Zeta thread that manages
 * channels callback calls.
 *
 */
#define ZT_MONITOR_THREAD_STACK_SIZE 1024


/**
 * @brief Storage sleep time.
 *
 */
#define ZT_STORAGE_SLEEP_TIME 30

/**
 * @brief Channels thread priority
 *
 */
#define ZT_MONITOR_THREAD_PRIORITY 0

#ifdef CONFIG_ZETA_STORAGE
/**
 * @brief Stack size that is used in Zeta thread that manages the
 * persistent data.
 *
 */
#define ZT_STORAGE_THREAD_STACK_SIZE 1024

/**
 * @brief Storage thread priority.
 *
 */
#define ZT_STORAGE_THREAD_PRIORITY 2
#endif

#ifdef CONFIG_ZETA_FORWARDER
/**
 * @brief Forwarder thread priority.
 *
 */
#define ZT_FORWARDER_THREAD_PRIORITY 1

/**
 * @brief Stack size that is used in Zeta thread that manages
 * the forwarder of messages between services and channels.
 *
 */
#define ZT_FORWARDER_THREAD_STACK_SIZE 2048

#define ZT_FWD_OP_READ 0
#define ZT_FWD_OP_PUBLISH 1
#define ZT_FWD_OP_CALLBACK 2
#define ZT_FWD_OP_SAVED 3
#endif

/**
 * @brief Declare a zeta service.
 *
 * @param _name Service name
 * @param _task Task pointer function
 * @param _cb Callback to be called when some subscribed channel change
 *
 */
#define ZT_SERVICE_DECLARE(_name, _task, _cb)                           \
    K_THREAD_STACK_DEFINE(_k_thread_stack_##_name, _name##_STACK_SIZE); \
    zt_service_t _name##_service = {                                    \
        .id          = ZT_##_name##_SERVICE,                            \
        .name        = #_name,                                          \
        .cb          = _cb,                                             \
        .entry_point = (k_thread_entry_t) _task,                        \
        .stack       = _k_thread_stack_##_name,                         \
        .stack_size  = K_THREAD_STACK_SIZEOF(_k_thread_stack_##_name)}

/**
 * @brief Run a zeta service.
 *
 * @param _name Service name
 *
 */
#define ZT_SERVICE_RUN(_name)                                                            \
    k_thread_create(&_name##_service.thread, _name##_service.stack,                      \
                    _name##_service.stack_size, _name##_service.entry_point, NULL, NULL, \
                    NULL, _name##_TASK_PRIORITY, 0, K_NO_WAIT)

/**
 * \
 * @brief Read variable reference and size easily \
 * to use in Zeta API.                            \
 *                                                \
 * @param x variable name                         \
 *                                                \
 */
#define ZT_VARIABLE_REF_SIZE(x) (uint8_t *) (&x), sizeof(x)

/**
 * @brief Check if _v value is equal to _c, otherwise _err will be
 * returned and a message will be sent to LOG.
 *
 * @param _v Value
 * @param _c Condition
 * @param _err Error code
 *
 */
#define ZT_CHECK_VAL(_p, _e, _err, ...) \
    if (_p == _e) {                     \
        LOG_INF(__VA_ARGS__);           \
        return _err;                    \
    }

/**
 * @brief Check if _v is true, otherwise _err will be returned and a
 * message will be sent to LOG.
 *
 * @param _v Value
 * @param _err Error code
 *
 * @return
 */
#define ZT_CHECK(_p, _err, ...) \
    if (_p) {                   \
        LOG_INF(__VA_ARGS__);   \
        return _err;            \
    }


#define ZT_DATA_S8(data)                   \
    (zt_data_t *) (zt_data_int8_t[])       \
    {                                      \
        {                                  \
            sizeof(int8_t), (int8_t)(data) \
        }                                  \
    }

#define ZT_DATA_U8(data)                     \
    (zt_data_t *) (zt_data_uint8_t[])        \
    {                                        \
        {                                    \
            sizeof(uint8_t), (uint8_t)(data) \
        }                                    \
    }

#define ZT_DATA_S16(data)                    \
    (zt_data_t *) (zt_data_int16_t[])        \
    {                                        \
        {                                    \
            sizeof(int16_t), (int16_t)(data) \
        }                                    \
    }

#define ZT_DATA_U16(data)                      \
    (zt_data_t *) (zt_data_uint16_t[])         \
    {                                          \
        {                                      \
            sizeof(uint16_t), (uint16_t)(data) \
        }                                      \
    }

#define ZT_DATA_S32(data)                    \
    (zt_data_t *) (zt_data_int32_t[])        \
    {                                        \
        {                                    \
            sizeof(int32_t), (int32_t)(data) \
        }                                    \
    }

#define ZT_DATA_U32(data)                      \
    (zt_data_t *) (zt_data_uint32_t[])         \
    {                                          \
        {                                      \
            sizeof(uint32_t), (uint32_t)(data) \
        }                                      \
    }

#define ZT_DATA_S64(data)                    \
    (zt_data_t *) (zt_data_int64_t[])        \
    {                                        \
        {                                    \
            sizeof(int64_t), (int64_t)(data) \
        }                                    \
    }

#define ZT_DATA_U64(data)                      \
    (zt_data_t *) (zt_data_uint64_t[])         \
    {                                          \
        {                                      \
            sizeof(uint64_t), (uint64_t)(data) \
        }                                      \
    }

#define ZT_DATA_BYTES(_size, data, ...) \
    (zt_data_t *) (struct {             \
        size_t size;                    \
        uint8_t value[_size];           \
    }[])                                \
    {                                   \
        {                               \
            _size,                      \
            {                           \
                data, ##__VA_ARGS__     \
            }                           \
        }                               \
    }

// <ZT_CODE_INJECTION>
#define ZT_DATA_SENSORS_MSG(data, ...) (zt_data_t *) (zt_data_sensors_msg_t[]) {{sizeof(struct sensors_msg), {data, ##__VA_ARGS__}}}

#define ZT_DATA_NET_REQUEST_MSG(data) (zt_data_t *) (zt_data_net_request_msg_t[]) {{sizeof(uint8_t)*1, data}}

#define ZT_DATA_NET_RESPONSE_MSG(data, ...) (zt_data_t *) (zt_data_net_response_msg_t[]) {{sizeof(uint8_t)*5, {data, ##__VA_ARGS__}}}
// </ZT_CODE_INJECTION>


typedef struct {
    size_t size;
    int8_t value;
} zt_data_int8_t;

typedef struct {
    size_t size;
    uint8_t value;
} zt_data_uint8_t;

typedef struct {
    size_t size;
    int16_t value;
} zt_data_int16_t;

typedef struct {
    size_t size;
    uint16_t value;
} zt_data_uint16_t;

typedef struct {
    size_t size;
    int32_t value;
} zt_data_int32_t;

typedef struct {
    size_t size;
    uint32_t value;
} zt_data_uint32_t;

typedef struct {
    size_t size;
    int64_t value;
} zt_data_int64_t;

typedef struct {
    size_t size;
    uint64_t value;
} zt_data_uint64_t;

typedef struct {
    size_t size;
    uint8_t value[];
} zt_data_bytes_t;

// <ZT_CODE_INJECTION>
struct sensors_msg {
    uint8_t a;
    uint8_t b;
    uint32_t c;
};

typedef struct {
    size_t size;
    struct sensors_msg value;
} zt_data_sensors_msg_t;


typedef struct {
    size_t size;
    uint8_t value ;
} zt_data_net_request_msg_t;


typedef struct {
    size_t size;
    uint8_t value [5];
} zt_data_net_response_msg_t;
// </ZT_CODE_INJECTION>

union data {
    zt_data_int8_t s8;
    zt_data_uint8_t u8;
    zt_data_int16_t s16;
    zt_data_uint16_t u16;
    zt_data_int32_t s32;
    zt_data_uint32_t u32;
    zt_data_int64_t s64;
    zt_data_uint64_t u64;
    // <ZT_CODE_INJECTION>
    zt_data_sensors_msg_t sensors_msg;
    zt_data_net_request_msg_t net_request_msg;
    zt_data_net_response_msg_t net_response_msg;
// </ZT_CODE_INJECTION>
    zt_data_bytes_t bytes;
};

typedef union data zt_data_t;

// <ZT_CODE_INJECTION>
typedef enum {
    ZT_FIRMWARE_VERSION_CHANNEL,
    ZT_SENSORS_CHANNEL,
    ZT_NET_REQUEST_CHANNEL,
    ZT_NET_RESPONSE_CHANNEL,
    ZT_CHANNEL_COUNT
} __attribute__((packed)) zt_channel_e;
// </ZT_CODE_INJECTION>

// <ZT_CODE_INJECTION>
typedef enum {
    ZT_CORE_SERVICE,
   ZT_BOARD_SERVICE,
   ZT_NET_SERVICE,
    ZT_SERVICE_COUNT
} __attribute__((packed)) zt_service_e;
// </ZT_CODE_INJECTION>

/**
 * @brief zeta_callback_f define the callback function type of Zeta.
 *
 * @param id Channel Id.
 *
 */
typedef void (*zt_callback_f)(zt_channel_e id);

/**
 * @brief Define Zeta service type
 */
struct zt_service {
    zt_service_e id;              /**< Service ID */
    const char *name;             /**< Service name */
    struct k_thread thread;       /**< Service RTOS thread */
    zt_callback_f cb;             /**< Service callback */
    k_thread_entry_t entry_point; /**< Service thread function (entry point) */
    k_thread_stack_t *stack;      /**< Service thread stack */
    size_t stack_size;            /**< Service thread stack size */
};
typedef struct zt_service zt_service_t;

struct zt_isc_packet {
    uint32_t id;
    uint8_t service_id;
    uint8_t channel_id;
    uint8_t op;
    uint8_t size;
    uint8_t message[4];
} __attribute__((packed));
typedef struct zt_isc_packet zt_isc_packet_t;

/**
 * @brief Define pendent options that a channel can have.
 */
union flag_data {
    struct {
        uint8_t pend_persistent : 1; /**< Active represent that channel must be saved in
                                     flash by zeta_thread_nvs */
        uint8_t pend_callback : 1;   /**< Active represent that services callbacks from
                                     subscribers must be called by zeta_thread */
        uint8_t on_changed : 1;      /**< Active represent that the service callback will
                                            be called on change and not on update */
    } field;
    uint8_t data; /**< Raw data */
};

/**
 * @brief Define Zeta channel type
 */
struct zt_channel {
    const char *name; /**< Channel name */
    uint8_t *data;    /**< Channel raw data */
    uint8_t read_only;
    uint8_t size;               /**< Channel size */
    uint8_t persistent;         /**< Persistent type */
    zt_channel_e id;            /**< Channel Id */
    union flag_data flag;       /**< Options */
    struct k_sem *sem;          /**< Preserve shared-memory */
    zt_service_t **publishers;  /**< Publishers */
    zt_service_t **subscribers; /**< Subscribers */
};
typedef struct zt_channel zt_channel_t;

/**
 * @brief Return the channel size.
 *
 * @param id Channel Id
 * @param error Handle possible errors
 *
 * @return Channel size
 */
size_t zt_channel_size(zt_channel_e id, int *error);

/**
 * @brief Return the channel name.
 *
 * @param id Channel Id
 * @param error Handle possible errors
 *
 * @return Channel name
 */
const char *zt_channel_name(zt_channel_e id, int *error);

/**
 * @brief Read channel value.
 *
 * @param id Channel Id
 * @param channel_data pointer to a zt_data_t where the data will be retrieved.
 *
 * @return Error code
 * @retval -ENODATA The channel was not found
 * @retval -EFAULT Channel value is NULL
 * @retval -EPERM  Channel hasn't read function implemented
 * @retval -EINVAL Size passed is different to channel size
 */
int zt_chan_read(zt_channel_e id, zt_data_t *channel_data);

/**
 * @brief Publish channel value.
 *
 * @param id Channel Id
 * @param channel_data pointer to a zt_data_t where the data is.
 *
 * @return Error code
 * @retval -ENODATA The channel was not found
 * @retval -EACCESS Current thread hasn't permission to publish this channel
 * @retval -EFAULT Channel value is NULL
 * @retval -EPERM Channel is read only
 * @retval -EINVAL Size passed is different to channel size
 * @retval -EAGAIN Valid function returns false
 */
int zt_chan_pub(zt_channel_e id, zt_data_t *channel_data);

// <ZT_CODE_INJECTION>
/* BEGIN CORE SECTION */
extern zt_service_t CORE_service;
#define CORE_TASK_PRIORITY 2
#define CORE_STACK_SIZE 2048
/* END CORE SECTION */

/* BEGIN BOARD SECTION */
extern zt_service_t BOARD_service;
#define BOARD_TASK_PRIORITY 1
#define BOARD_STACK_SIZE 2048
/* END BOARD SECTION */

/* BEGIN NET SECTION */
extern zt_service_t NET_service;
#define NET_TASK_PRIORITY 3
#define NET_STACK_SIZE 2048
/* END NET SECTION */
// </ZT_CODE_INJECTION>

#endif
